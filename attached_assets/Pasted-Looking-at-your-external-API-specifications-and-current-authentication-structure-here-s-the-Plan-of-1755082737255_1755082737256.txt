Looking at your external API specifications and current authentication structure, here's the Plan of Action for Phase 4: Login Integration:

Current State Analysis
Your login currently:

Only checks local PostgreSQL database
Uses internal JWT tokens (7-day expiration)
Stores tokens in HTTP-only cookies
No integration with external verification system
Phase 4 Integration Plan
Step 1: Modify Login API Route (/app/api/auth/login/route.ts)
Current Flow: Email/Password → Local DB Check → Internal JWT → Cookie
New Flow: Email/Password → External API Call → Local DB Sync → Token Management

Changes Needed:
Add External API Call: Call {{forex_url}}api/accounts/login with email, password, and platform: "AI Call"
Verification Check: Ensure user is verified: true in external response
Token Decision: Choose between external token vs internal token
User Sync: Update local database with latest external user data
Fallback Logic: Handle external API failures gracefully
Step 2: Token Management Strategy
Option A: Use External Tokens

Store external JWT token in HTTP-only cookie
Validate external tokens in middleware
Sync token expiration with external system
Option B: Hybrid Approach (Recommended)

Use external API for authentication validation
Generate internal JWT for session management
Store external _id and verified status in internal token
Refresh external validation periodically
Step 3: Update Auth Context (/contexts/auth-context.tsx)
Login Function: Handle new external API integration
Error Handling: Manage external API specific errors
User State: Store combined local + external user data
Token Storage: Decide between localStorage vs cookies for external token
Step 4: Middleware Updates (/middleware.ts)
Dual Validation: Check both internal session and external verification
Token Refresh: Handle external token expiration
Fallback Logic: Allow access during external API downtime
Step 5: User Synchronization
Login Sync: Update local user record with external data on each login
Verification Status: Keep local is_verified in sync with external verified
Profile Updates: Decide which system is source of truth for user data
Key Decisions Needed
1. Token Storage Location
HTTP-only Cookies (current): More secure, works with SSR
localStorage: Required for external token access in client-side
2. Token Management Approach
External Token Only: Simpler but dependent on external system
Dual Token System: More complex but more reliable
Internal Token with External Validation: Balance of both
3. User Data Source of Truth
External API: Always fetch fresh data
Local Database: Cache with periodic sync
Hybrid: Local cache with external validation
Recommended Approach
Phase 4A: Core Integration

Modify login to call external API first
Verify user is verified and active
Update local database with external data
Generate internal JWT with external user ID reference
Store both internal JWT (cookie) and external token (localStorage)
Phase 4B: Enhanced Features

Add token refresh logic
Implement periodic verification checks
Add fallback for external API downtime
Sync user profile updates
This approach maintains your current security model while integrating with the external system for verification and authentication.